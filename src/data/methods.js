export const MEGA_PACK = [
  {
    section: "arrays",
    name: ".push(novoItem)",
    badge: "Adicionar",
    desc: "Adiciona no final e retorna o novo tamanho.",
    tags: "arrays adicionar push pilha stack fim",
    code: `const itensDoCarrinho = ["mouse óptico", "teclado mecânico"];\nconst novoTamanho = itensDoCarrinho.push("monitor 24\""); // 3`,
  },
  {
    section: "arrays",
    name: ".pop()",
    badge: "Remover",
    desc: "Remove e retorna o último item.",
    tags: "arrays remover pop fim undo pilha stack",
    code: `const filaDeAtendimento = ["pedido-101", "pedido-102", "pedido-103"];\nconst ultimoAtendido = filaDeAtendimento.pop(); // "pedido-103"`,
  },
  {
    section: "arrays",
    name: ".unshift(item)",
    badge: "Adicionar",
    desc: "Adiciona no início e retorna o novo tamanho.",
    tags: "arrays fila fifo unshift inicio",
    code: `const fila = ["b","c"]; const n = fila.unshift("a"); // 3`,
  },
  {
    section: "arrays",
    name: ".shift()",
    badge: "Remover",
    desc: "Remove e retorna o primeiro item.",
    tags: "arrays shift remover inicio fifo",
    code: `const fila = ["a","b","c"]; const primeiro = fila.shift(); // "a"`,
  },
  {
    section: "arrays",
    name: ".slice(inicio, fim)",
    badge: "Cópia",
    desc: "Copia parte do array sem alterar o original.",
    tags: "arrays slice copia imutavel",
    code: `const a=[1,2,3,4]; const b=a.slice(1,3); // [2,3]`,
  },
  {
    section: "arrays",
    name: ".splice(idx, qtd, ...itens)",
    badge: "Editar",
    desc: "Remove/insere no meio alterando o array original.",
    tags: "arrays splice editar mutavel",
    code: `const a=[1,2,3,4]; a.splice(1,2,9,9); // a => [1,9,9,4]`,
  },
  {
    section: "arrays",
    name: ".concat(...arrs)",
    badge: "Juntar",
    desc: "Retorna novo array concatenando arrays/itens.",
    tags: "arrays concat juntar imutavel",
    code: `const a=[1,2]; const b=[3,4]; const c=a.concat(b,5); // [1,2,3,4,5]`,
  },
  {
    section: "arrays",
    name: ".indexOf/lastIndexOf",
    badge: "Buscar",
    desc: "Índice de um valor (ou -1).",
    tags: "arrays indexof buscar",
    code: `["a","b","c","b"].lastIndexOf("b"); // 3`,
  },
  {
    section: "transform",
    name: ".map(fn)",
    badge: "Transformar",
    desc: "Retorna um novo array transformando item a item.",
    tags: "arrays transformar map imutável",
    code: `const precos = [100, 250];\nconst comImposto = precos.map(p => p * 1.2); // [120, 300]`,
  },
  {
    section: "transform",
    name: ".filter(fn)",
    badge: "Filtrar",
    desc: "Cria um novo array com itens que passam no teste.",
    tags: "arrays filtrar filter busca",
    code: `const pedidos = [\n  { id: 1, pago: true,  total: 50 },\n  { id: 2, pago: false, total: 80 },\n  { id: 3, pago: true,  total: 30 }\n];\nconst pagos = pedidos.filter(p => p.pago);`,
  },
  {
    section: "transform",
    name: ".reduce(fn, inicial)",
    badge: "Acumular",
    desc: "Diminui a um único valor (soma, objeto, mapa).",
    tags: "arrays reduce somar acumular totalizar",
    code: `const compras = [{preco: 30}, {preco: 20}, {preco: 50}];\nconst total = compras.reduce((acc, c) => acc + c.preco, 0); // 100`,
  },
  {
    section: "transform",
    name: ".find(fn)",
    badge: "Buscar",
    desc: "Retorna o primeiro item que satisfaz a condição.",
    tags: "arrays find buscar",
    code: `const u=[{id:1},{id:2}]; const dois = u.find(x=>x.id===2);`,
  },
  {
    section: "transform",
    name: ".findIndex(fn)",
    badge: "Buscar",
    desc: "Índice do primeiro que satisfaz a condição (ou -1).",
    tags: "arrays findIndex",
    code: `["a","bb","ccc"].findIndex(s => s.length===2); // 1`,
  },
  {
    section: "transform",
    name: ".some(fn)",
    badge: "Checar",
    desc: "Algum item passa no teste?",
    tags: "arrays some algum",
    code: `[1,3,5].some(n => n%2===0); // false`,
  },
  {
    section: "transform",
    name: ".every(fn)",
    badge: "Checar",
    desc: "Todos passam no teste?",
    tags: "arrays every todos",
    code: `[2,4,6].every(n => n%2===0); // true`,
  },
  {
    section: "transform",
    name: ".flat(n)",
    badge: "Achatar",
    desc: "Achatamento em n níveis (default 1).",
    tags: "arrays flat",
    code: `[1,[2,[3]]].flat(2); // [1,2,3]`,
  },
  {
    section: "transform",
    name: ".flatMap(fn)",
    badge: "Map + flat",
    desc: "Mapeia e achata 1 nível.",
    tags: "arrays flatMap",
    code: `["a b","c"].flatMap(s=>s.split(" ")); // ["a","b","c"]`,
  },
  {
    section: "transform",
    name: "localeCompare()",
    badge: "Ordenar texto",
    desc: "Ordena strings respeitando locale/acentos.",
    tags: "arrays sort texto localeCompare",
    code: `["êxito","exato","éden"].sort((a,b)=>a.localeCompare(b,"pt-BR"));`,
  },
  {
    section: "objects",
    name: "Object.keys(obj)",
    badge: "Iterar",
    desc: "Retorna array com as chaves próprias do objeto.",
    tags: "objetos keys propriedades",
    code: `const perfil = { id: 7, nome: "Aline", plano: "premium" };\nconst chaves = Object.keys(perfil); // ["id","nome","plano"]`,
  },
  {
    section: "objects",
    name: "Spread & Desestruturação",
    badge: "Essencial",
    desc: "Combine objetos e extraia apenas o que precisa.",
    tags: "objetos spread desestruturacao",
    code: `const pedido = { id: 10, total: 99.9, cliente: { nome: "Aline" } };\nconst { total, cliente: { nome } } = pedido;\n\nconst base = { tema: "claro", fonte: "16px" };\nconst prefs = { ...base, tema: "escuro" };`,
  },
  {
    section: "objects",
    name: "Object.values(obj)",
    badge: "Iterar",
    desc: "Array com valores próprios do objeto.",
    tags: "objetos values",
    code: `Object.values({a:1,b:2}); // [1,2]`,
  },
  {
    section: "objects",
    name: "Object.entries / fromEntries",
    badge: "Converter",
    desc: "Objeto ↔ pares [chave, valor].",
    tags: "objetos entries fromentries",
    code: `const o={a:1,b:2}; const pares=Object.entries(o); const volta=Object.fromEntries(pares);`,
  },
  {
    section: "objects",
    name: "Object.hasOwn(obj, key)",
    badge: "Seguro",
    desc: "Checa propriedade própria (não herdada).",
    tags: "objetos hasOwn",
    code: `Object.hasOwn({x:1},"x"); // true`,
  },
  {
    section: "objects",
    name: "Object.assign(target, src)",
    badge: "Mesclar",
    desc: "Copia propriedades para o destino.",
    tags: "objetos assign mesclar",
    code: `Object.assign({a:1},{b:2}); // {a:1,b:2}`,
  },
  {
    section: "objects",
    name: "structuredClone(obj)",
    badge: "Deep copy",
    desc: "Cópia profunda nativa (dados puros).",
    tags: "objetos clone deep",
    code: `const copia = structuredClone({a:{b:1}});`,
  },
  {
    section: "objects",
    name: "Object.freeze / seal",
    badge: "Imutabilidade",
    desc: "Trava adição/remoção/edição.",
    tags: "objetos freeze seal imutabilidade",
    code: `const cfg=Object.freeze({tema:"dark"}); /* cfg.tema="light" // erro em strict */`,
  },
  {
    section: "objects",
    name: "Object.defineProperty",
    badge: "Avançado",
    desc: "Define meta (enumerable, writable...).",
    tags: "objetos defineProperty meta",
    code: `const o={}; Object.defineProperty(o,"segredo",{value:42,writable:false});`,
  },
  {
    section: "strings",
    name: ".includes(txt)",
    badge: "Buscar",
    desc: "Verifica se a substring existe na string.",
    tags: "strings includes buscar",
    code: `const email = "aline@empresa.com";\nconst corporativo = email.includes("@empresa"); // true`,
  },
  {
    section: "strings",
    name: ".replace/.replaceAll",
    badge: "Normalizar",
    desc: "Substitui partes da string.",
    tags: "strings replace replaceall normalizar",
    code: `const br = "R$ 1.234,56";\nconst padrao = br.replace("R$ ","").replaceAll(".","").replace(",","."); // "1234.56"`,
  },
  {
    section: "strings",
    name: ".trim / trimStart / trimEnd",
    badge: "Limpar",
    desc: "Remove espaços das pontas.",
    tags: "strings trim",
    code: `"  oi  ".trim(); // "oi"`,
  },
  {
    section: "strings",
    name: ".padStart / padEnd",
    badge: "Formatar",
    desc: "Preenche até um tamanho fixo.",
    tags: "strings padStart padEnd",
    code: `"7".padStart(3,"0"); // "007"`,
  },
  {
    section: "strings",
    name: ".split / .join",
    badge: "Tokenizar",
    desc: "Divide e junta strings.",
    tags: "strings split join",
    code: `"a,b,c".split(",").join(" | ");`,
  },
  {
    section: "strings",
    name: ".startsWith / .endsWith",
    badge: "Checar",
    desc: "Prefixo/sufixo.",
    tags: "strings startsWith endsWith",
    code: `"notas.txt".endsWith(".txt"); // true`,
  },
  {
    section: "strings",
    name: ".match / regex",
    badge: "Regex",
    desc: "Extrai padrões com RegExp.",
    tags: "strings match regex",
    code: `"abc123".match(/\d+/)[0]; // "123"`,
  },
  {
    section: "strings",
    name: "Template literals",
    badge: "Interpolar",
    desc: "Strings com crase e ${} variáveis.",
    tags: "strings template literals",
    code: "const nome='Aline'; const s=`Olá, ${'${nome}'}!`;",
  },
  {
    section: "numbers",
    name: "Number/parseInt/parseFloat",
    badge: "Converter",
    desc: "Convertem texto em número.",
    tags: "numeros parse conversao",
    code: `Number("42");\nparseInt("08", 10);\nparseFloat("3.14");`,
  },
  {
    section: "numbers",
    name: "toFixed / Intl.NumberFormat",
    badge: "Moeda",
    desc: "Formatação de número.",
    tags: "numeros formatar moeda",
    code: `(1234.5).toFixed(2); // "1234.50"\nnew Intl.NumberFormat("pt-BR",{style:"currency",currency:"BRL"}).format(1234.5);`,
  },
  {
    section: "numbers",
    name: "Math.max/min & spread",
    badge: "Úteis",
    desc: "Maior/menor rapidamente.",
    tags: "numeros math max min",
    code: `const v=[5,10,2]; Math.max(...v); // 10`,
  },
  {
    section: "dates",
    name: ".toLocaleString()",
    badge: "Formatar",
    desc: "Formata data/hora considerando locale e fuso.",
    tags: "datas tolocalestring timezone fuso",
    code: `const dataEvento = new Date("2025-08-22T10:30:00Z");\nconst exibicaoBR = dataEvento.toLocaleString("pt-BR", { timeZone: "America/Sao_Paulo" });`,
  },
  {
    section: "dates",
    name: "Date.now()",
    badge: "Timestamp",
    desc: "Millis desde 1970.",
    tags: "datas now timestamp",
    code: `const t0=Date.now(); /* ... */ const dt=Date.now()-t0;`,
  },
  {
    section: "dates",
    name: "Adicionar dias",
    badge: "Cálculo",
    desc: "Some dias sem libs.",
    tags: "datas add dias",
    code: `const addDays=(d,n)=>{const x=new Date(d); x.setDate(x.getDate()+n); return x;};`,
  },
  {
    section: "dates",
    name: "Diferença em dias",
    badge: "Cálculo",
    desc: "Entre duas datas.",
    tags: "datas diff dias",
    code: `const diffDays=(a,b)=>Math.ceil((b-a)/(1000*60*60*24));`,
  },
  {
    section: "json",
    name: "JSON.parse / JSON.stringify",
    badge: "Serializar",
    desc: "Converta entre texto e objeto com segurança.",
    tags: "json parse stringify serializar",
    code: `const resposta = '{"ok":true,"itens":[1,2]}';\nconst dados = JSON.parse(resposta);\nconst log = JSON.stringify(dados, null, 2);`,
  },
  {
    section: "json",
    name: "Safe parse (try/catch)",
    badge: "Robusto",
    desc: "Parse com fallback.",
    tags: "json parse seguro",
    code: `function safeParse(s,fb=null){try{return JSON.parse(s)}catch{return fb}}`,
  },
  {
    section: "async",
    name: "async/await + Promise.all",
    badge: "IO moderno",
    desc: "Fluxo assíncrono limpo com tratamento de erros.",
    tags: "async await try catch promise all",
    code: `async function carregarPainelDoUsuario(id){\n  try {\n    const perfil = await buscarPerfil(id);\n    const [notificacoes, pedidos] = await Promise.all([\n      buscarNotificacoes(id),\n      buscarPedidos(id)\n    ]);\n    return { perfil, notificacoes, pedidos };\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}`,
  },
  {
    section: "async",
    name: "fetch básico (GET)",
    badge: "HTTP",
    desc: "Busca dados com tratamento de erro.",
    tags: "async fetch",
    code: `async function getJson(url){\n  const res = await fetch(url);\n  if (!res.ok) throw new Error(res.status);\n  return res.json();\n}`,
  },
  {
    section: "async",
    name: "AbortController",
    badge: "Cancelar",
    desc: "Cancelar fetch demorado.",
    tags: "async abort controller",
    code: `const ctl=new AbortController();\nconst t=setTimeout(()=>ctl.abort(), 3000);\nfetch("/api", {signal:ctl.signal}).catch(console.warn).finally(()=>clearTimeout(t));`,
  },
  {
    section: "logic",
    name: "Encadeamento opcional (?.) & Coalescência (??)",
    badge: "Seguro",
    desc: "Acesse caminhos profundos sem quebrar e defina padrões.",
    tags: "logica optional chaining nullish ?? ?.",
    code: `const cidade = cliente?.endereco?.cidade ?? "sem cadastro";`,
  },
  {
    section: "logic",
    name: "Debounce",
    badge: "UX",
    desc: "Aguarda parar de digitar.",
    tags: "utils debounce input",
    code: `const debounce=(fn,ms=300)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); } };`,
  },
  {
    section: "logic",
    name: "Throttle",
    badge: "UX",
    desc: "Limita chamadas/tempo.",
    tags: "utils throttle scroll",
    code: `const throttle=(fn,ms=200)=>{ let p=0; return (...a)=>{ const n=Date.now(); if(n-p>ms){ p=n; fn(...a); } } };`,
  },
  {
    section: "logic",
    name: "Set & Map",
    badge: "Coleções",
    desc: "Úteis para unicidade e pares chave/valor.",
    tags: "set map colecoes",
    code: `const s=new Set([1,1,2]); // {1,2}\nconst m=new Map([["chave",42]]); m.get("chave");`,
  },
  {
    section: "logic",
    name: "WeakMap cache",
    badge: "Desempenho",
    desc: "Cache ligado ao ciclo de vida.",
    tags: "weakmap cache",
    code: `const cache=new WeakMap();\nfunction parseOnce(obj){ if(cache.has(obj)) return cache.get(obj);\nconst r=JSON.parse(obj.text); cache.set(obj,r); return r; }`,
  },
  {
    section: "logic",
    name: "Memoize",
    badge: "Desempenho",
    desc: "Evita recomputar função pura.",
    tags: "memo memoize cache",
    code: `const memoize=fn=>{ const c=new Map();\nreturn x=> c.has(x)?c.get(x):(c.set(x,fn(x)),c.get(x)); };`,
  },
,
  // ==== Extra entries injected from user's study material ====
  {
    section: "arrays",
    name: ".at(index)",
    badge: "Acesso",
    desc: "Acessa por índice (aceita negativos).",
    tags: "arrays at indice negativo acesso",
    code: `const vendas=[150,200,180,220,300]; vendas.at(-1); // 300`,
  },
  {
    section: "arrays",
    name: ".includes(valor)",
    badge: "Checar",
    desc: "Verifica se o valor existe no array.",
    tags: "arrays includes checar permissao",
    code: `const perms=["ler","escrever"]; perms.includes("escrever"); // true`,
  },
  {
    section: "arrays",
    name: ".join(sep)",
    badge: "String",
    desc: "Une itens em uma string com separador.",
    tags: "arrays join string breadcrumb csv",
    code: `["Home","Produtos","Notebooks"].join("/"); // "Home/Produtos/Notebooks"`,
  },
  {
    section: "arrays",
    name: ".reverse()",
    badge: "Inverter",
    desc: "Inverte a ordem (muta o array).",
    tags: "arrays reverse inverter mutavel",
    code: `const a=[1,2,3]; a.reverse(); // [3,2,1]`,
  },
  {
    section: "arrays",
    name: ".findLast / .findLastIndex",
    badge: "Buscar do fim",
    desc: "Retorna o último item/índice que satisfaz.",
    tags: "arrays findlast findlastindex buscar ultimo",
    code: `[{nivel:"info"},{nivel:"error"}].findLast(x=>x.nivel==="error");`,
  },
  {
    section: "arrays",
    name: ".forEach(fn)",
    badge: "Iterar",
    desc: "Executa fn para cada item (não retorna).",
    tags: "arrays foreach iterar efeitos colaterais",
    code: `["a","b"].forEach((v,i)=>console.log(i,v));`,
  },
  {
    section: "arrays",
    name: ".sort(cmp)",
    badge: "Ordenar",
    desc: "Ordena com comparador (muta).",
    tags: "arrays sort ordenar comparador",
    code: `const n=[10,2,30,4]; n.sort((a,b)=>a-b); // [2,4,10,30]`,
  },
  {
    section: "objects",
    name: "delete obj.prop",
    badge: "Remover",
    desc: "Remove propriedade do objeto.",
    tags: "objetos delete remover sanitizar",
    code: `const r={user:"ana",senha:"x"}; delete r.senha;`,
  },
  {
    section: "objects",
    name: `"chave" in obj`,
    badge: "Checar",
    desc: "Verifica existência (inclui herdadas).",
    tags: "objetos in existencia prototype",
    code: `("toString" in {}); // true`,
  },
  {
    section: "strings",
    name: ".indexOf / .lastIndexOf",
    badge: "Posição",
    desc: "Índice da substring (ou -1).",
    tags: "strings indexof lastindexof posicao",
    code: `"arquivo.txt".lastIndexOf("."); // 7`,
  },
  {
    section: "strings",
    name: ".slice / .substring",
    badge: "Extrair",
    desc: "Fatias de string (substring não aceita negativos).",
    tags: "strings slice substring extrair",
    code: `"BR1234567890XY".slice(0,2); // "BR"`,
  },
  {
    section: "strings",
    name: ".toLowerCase / .toUpperCase",
    badge: "Normalizar",
    desc: "Ajusta capitalização para comparações/formatos.",
    tags: "strings case minusculo maiusculo normalizar",
    code: `"Ana SILVA".toLowerCase(); // "ana silva"`,
  },
  {
    section: "strings",
    name: ".repeat(n)",
    badge: "Repetir",
    desc: "Repete a string n vezes.",
    tags: "strings repeat decoracao progresso",
    code: `"=".repeat(10); // "=========="`,
  },
  {
    section: "numbers",
    name: "Number.isNaN / isFinite / isInteger",
    badge: "Validar",
    desc: "Utilitários de validação numérica.",
    tags: "numeros validacao isnan isfinite isinteger",
    code: `Number.isNaN(Number("abc")); // false, NaN é que é true`,
  },
  {
    section: "numbers",
    name: "toPrecision / toExponential",
    badge: "Precisão",
    desc: "Formatos científicos e dígitos significativos.",
    tags: "numeros precisao exponencial",
    code: `(123.456).toPrecision(4); // "123.5"`,
  },
  {
    section: "numbers",
    name: "Math.round / floor / ceil / trunc",
    badge: "Arredondar",
    desc: "Arredondamentos comuns.",
    tags: "numeros arredondar round floor ceil trunc",
    code: `Math.trunc(-4.9); // -4`,
  },
  {
    section: "numbers",
    name: "Math.random() & helpers",
    badge: "Aleatório",
    desc: "Inteiros em faixa e embaralhar.",
    tags: "numeros random aleatorio",
    code: `const r=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;`,
  },
  {
    section: "numbers",
    name: "Potência & Raiz",
    badge: "Pow/Sqrt",
    desc: "Operador ** e Math.sqrt.",
    tags: "numeros pow sqrt potencia",
    code: `2**3; // 8, Math.sqrt(16); // 4`,
  },
  {
    section: "numbers",
    name: "Math.abs & constantes",
    badge: "Absoluto",
    desc: "Valor absoluto e constantes (PI, E...).",
    tags: "numeros abs constantes",
    code: `Math.abs(-5); // 5; Math.PI; // 3.1415...`,
  },
  {
    section: "dates",
    name: "new Date(...)",
    badge: "Criar",
    desc: "Construtores: atual, ISO, timestamp, componentes.",
    tags: "datas new date criar",
    code: `new Date(); new Date("2025-01-01T00:00:00Z"); new Date(1700000000000);`,
  },
  {
    section: "dates",
    name: "get*/set*",
    badge: "Componentes",
    desc: "Extrai e altera partes (mês é 0-indexado).",
    tags: "datas get set componentes",
    code: `const d=new Date(); d.setDate(d.getDate()+7);`,
  },
  {
    section: "dates",
    name: ".toISOString()",
    badge: "ISO 8601",
    desc: "Formato seguro para APIs e BD.",
    tags: "datas iso padrao",
    code: `new Date().toISOString();`,
  },
  {
    section: "json",
    name: "replacer / reviver",
    badge: "Custom",
    desc: "Transforme durante stringify/parse.",
    tags: "json replacer reviver transformar",
    code: `JSON.stringify(obj,(k,v)=>k==="email"?"***":v);
JSON.parse(s,(k,v)=>/Data/i.test(k)?new Date(v):v);`,
  },
  {
    section: "json",
    name: "Limitações JSON",
    badge: "Atenção",
    desc: "Funções/undefined somem; Date vira string.",
    tags: "json limitacoes datas undefined funcao",
    code: `JSON.stringify({x:undefined,f(){}}); // "{}"`,
  },
];
